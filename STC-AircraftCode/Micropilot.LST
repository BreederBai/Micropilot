C51 COMPILER V9.01   MICROPILOT                                                            04/30/2017 10:50:26 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE MICROPILOT
OBJECT MODULE PLACED IN Micropilot.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Micropilot.C LARGE BROWSE DEBUG OBJECTEXTEND

line level    source

   1          //׼ַ                      http://shop112966725.taobao.com
   2          //                                                 STCunio
   3          //Ĵ   ϿƼѧ ϢѧԺ 13   ֧QQ1203933924   
   4          //ֻṩ޼֧,ֹʱ䣺201531,ʱš
   5          //˽ڣڼʱ벻Ҫ򼰱ӲķΧʲôߵչݶ
             -˲
   6          //ͲҪˣҲѧԶԭǸСSTM32ᣬᶼֻܿƵ51
             -Ƭ
   7          //ȫԴڽжοǲϸСĶԼӵаȨ
   8          //ڳϮԼаȨԼֻ˵QNMLGB
   9          
  10          //޸ıӦע⣡
  11          //˳Ż޸ģӹܣ뿪ԴĪ̳ STC 1TƬ 
  12          //ʹñӦѭGNUGPLЭ飡
  13          
  14          //ڱӲհ汾ǻ᲻ڵķ޸Bugĳ
  15          
  16          //رлзиֵ֧Ѽ壺
  17          //                                         ϿƼѧ 09 
  18          //                                         ϿƼѧ Ƕʽʵ οƾ
  19          //                                         ϿƼѧ պѧ߿ѧʵ
  20          //*************************************2015214 ***************************************************
             -***********
  21          //Ӳ
  22          //:1S/3.7V Ƽ300-650mAh   500mahϵĵƼװڱ
  23          ///:720ı/59MM         
  24          //   رԵĿıΪԱ ڽʢ 720ı ҵĵڱ򣬳
             -еPID
  25          //             ԵΪԱ ƽ۵ 59MMֱ 1mm׾ ҵڱ
             -򣬳еPID
  26          //MCU IAP15W4K61S4@28.000MHZ  (B棡A浥ƬԲʺϣ)
  27          //ر˵ĿǰֻʺIAPϵеĵƬIAPƬʹ޸EEPROMдַ
  28          //ǼٶȼƣMPU-6050 
  29          //оƬ:NRF24L01
  30          //MOS:AO3400
  31          //ѹ:BL8530
  32          //3.3Vѹ:ME6219C-33-M5G
  33          //ؿڱ:1K
  34          //ܳߴ:94mm*94mm
  35          
  36          //ʧĵط
  37          //MOSܱõФػŴλãȫӰʹãС᲻ФػС
  38          
  39          //
  40          //̬㣺Ԫ
  41          //˲˲From ¹Դᣩ
  42          //PIDPID ⻷PI,ڻPID
  43          
  44          //ݶ˵
  45          //data 51ƬƬRAMǰ128ֽRAM ACCдٶ
  46          //idata ƬRAMǰ256ֽڵRAM data ָģʽ ʺָ
  47          //pdata ⲿչRAMǰ256ֽڵRAM Ҫ 裡
  48          //xdata ⲿչRAM DPTR
  49          #include <STC15W4K60S4.H>
  50          #include <intrins.h>
C51 COMPILER V9.01   MICROPILOT                                                            04/30/2017 10:50:26 PAGE 2   

  51          #include <NRF24L01.H>
  52          #include <MPU6050.H>
  53          #include <math.h>
  54          #include <STC15W4KPWM.H>
  55          #include <Timer.h>
  56          #include <EEPROM.h>
  57          #include <USART.h>
  58          #include <IMU.H>
  59          //******************************************************************************************************
  60          float XE=0,YE=0;                 //ǶΪƯһӲɵģʲֵдEEPROM
             -ӦʹãƯӦ
  61                                           //λǷʱ
  62          float YM=0;              //ű仯ٶȿƣĻٱ仯ʱʧٷתGG
  63          int ich1=0,ich2=0,ich3=0,ich4=0,ich5=0,ich6=0;                           //ߴ/
  64          int speed0=0,speed1=0,speed2=0,speed3=0,V=0;           //ٶȲ
  65          int PWM0=0,PWM1=0,PWM2=0,PWM3=0;  //PWMģĲ
  66          int g_x=0,g_y=0,g_z=0;            //ǽ
  67          char a_x=0,a_y=0;                 //ǶȽ
  68          unsigned char TxBuf[20]={0};
  69          unsigned char RxBuf[20]={0};  
  70          double PID_x=0,PID_y=0,PID_z=0;  //PID
  71          float FR1=0,FR2=0,FR3=0;         //charתΪfloat
  72          //*****************ǶȲ*************************************************
  73          double Gyro_y=0,Gyro_x=0,Gyro_z=0;        //Yݴ
  74          double Accel_x=0,Accel_y=0,Accel_z=0;       //Xٶֵݴ
  75          double Angle_ax=0,Angle_ay=0,Angle_az=0;  //ɼٶȼļٶ()
  76          double Angle_gy=0,Angle_gx=0,Angle_gz=0;  //ɽٶȼĽ(Ƕ)
  77          double AngleAx=0,AngleAy=0;               //Ǻŷ
  78          double Angle=0,Angley=0;                  //Ԫŷ degree
  79          double Anglezlate=0;                      //Z
  80          double Ax=0,Ay=0;                         //ңĽǶ
  81          //****************̬PID*********************************************
  82          float Out_PID_X=0,Last_Angle_gx=0;//⻷PI  һ
  83          float Out_XP=35,Out_XI=0.01,ERRORX_Out=0;//⻷P  ⻷I  ⻷
  84          float In_XP=0.4,In_XI=0.01,In_XD=9,ERRORX_In=0;//ڻP  ڻI   ڻD  ڻ
  85          
  86          float Out_PID_Y=0,Last_Angle_gy=0;
  87          float Out_YP=35,Out_YI=0.01,ERRORY_Out=0;
  88          float In_YP=0.4,In_YI=0.01,In_YD=9,ERRORY_In=0;
  89          
  90          float ZP=5.0,ZD=4.0;//ƵP D
  91          
  92          int lastR0=0,ZT=0; //һRxBuf[0](RxBuf[0]ڲϱ䶯)   ״̬ʶ
  93          int i=0;
  94          void Angle_Calculate() interrupt 1 
  95          {       
  96   1              //if(YM<RxBuf[4]&&(RxBuf[4]-YM)<=2){YM++;YM++;}
  97   1              //else if(YM>RxBuf[4]&&(YM-RxBuf[4])<=2){YM--;YM--;}  //ֹű仯ʧ
  98   1              //else {YM=RxBuf[4];}
  99   1              if(RxBuf[1]>FR1){FR1+=0.2;}else if(RxBuf[1]<FR1){FR1-=0.2;}
 100   1              if(RxBuf[2]>FR2){FR2+=0.2;}else if(RxBuf[2]<FR2){FR2-=0.2;}
 101   1              
 102   1              YM=(float)RxBuf[4]*3/4;
 103   1              
 104   1              if(YM>100)//Ŵ100 ʼ
 105   1              {
 106   2                      if(RxBuf[0]==lastR0)//RxBuf[0]ûյ ʸ
 107   2                      {
 108   3                              ZT++;  //״̬ʶ+1
 109   3                              if(ZT>128){ZT=128;}  //״̬ʶ1281ûյݣʧر
 110   3                      }
 111   2                      else{ZT=0;}
C51 COMPILER V9.01   MICROPILOT                                                            04/30/2017 10:50:26 PAGE 3   

 112   2              }
 113   1              else{ZT=0;} //յź˳ʧر
 114   1              if(ZT==128){YM=101;RxBuf[1]=128;RxBuf[2]=128;} //ʧر Ϊ1һ㣬½
             -
 115   1              lastR0=RxBuf[0];
 116   1              
 117   1              i++;
 118   1              if(i==130){i=129;}
 119   1              Accel_y= GetData(ACCEL_YOUT_H); //ȡ6050
 120   1              Accel_x= GetData(ACCEL_XOUT_H);            
 121   1              Accel_z= GetData(ACCEL_ZOUT_H);      
 122   1              Gyro_x = GetData(GYRO_XOUT_H)-g_x;
 123   1              Gyro_y = GetData(GYRO_YOUT_H)-g_y;
 124   1              Gyro_z = GetData(GYRO_ZOUT_H)-g_z;      
 125   1              Last_Angle_gx=Angle_gx;   //һνٶ
 126   1              Last_Angle_gy=Angle_gy; 
 127   1              Angle_ax=(Accel_x)/8192;  //ٶȴ
 128   1              Angle_az=(Accel_z)/8192;  //ٶ +-4g/S
 129   1              Angle_ay=(Accel_y)/8192;        //תϵ8192LSB/g
 130   1              Angle_gx=(Gyro_x)/65.5;   //Ǵ
 131   1              Angle_gy=(Gyro_y)/65.5;   // +-500/S
 132   1              Angle_gz=(Gyro_z)/65.5;   //תϵ65.5LSB/
 133   1      //***********************************Ԫ***********************************
 134   1              IMUupdate(Angle_gx*0.0174533,Angle_gy*0.0174533,Angle_gz*0.0174533,Angle_ax,Angle_ay,Angle_az);
 135   1              //0.174533ΪPI/180 ĿǽǶת
 136   1      //********************ǺֱӽԹȽԪ㾫׼********************
 137   1              AngleAx=atan(Angle_ax/sqrt(Angle_ay*Angle_ay+Angle_az*Angle_az))*57.2957795f; //180/PI Ŀ
             -תǶ
 138   1        AngleAy=atan(Angle_ay/sqrt(Angle_ax*Angle_ax+Angle_az*Angle_az))*57.2957795f;
 139   1      //**************Xָ***********************************************************
 140   1              FR1=((float)RxBuf[1]-128)/7; //charתΪfloatԱ
 141   1              
 142   1              Ax=Angle-FR1-a_x;      //ǶȿǶ
 143   1              
 144   1              if(YM>20)
 145   1              {
 146   2              ERRORX_Out+=Ax;//⻷(Сĳֵʱ)
 147   2              }
 148   1              else
 149   1              {
 150   2                      ERRORX_Out=0; //Сڶֵʱֵ
 151   2              }
 152   1              if(ERRORX_Out>500){ERRORX_Out=500;}
 153   1              else if(ERRORX_Out<-500){ERRORX_Out=-500;}//޷
 154   1              
 155   1              Out_PID_X=Ax*Out_XP+ERRORX_Out*Out_XI;//⻷PI
 156   1              
 157   1              if(YM>20)
 158   1              {
 159   2             ERRORX_In+=(Angle_gy-Out_PID_X);  //ڻ(Сĳֵʱ)
 160   2              }       
 161   1          else
 162   1              {
 163   2                      ERRORX_In=0; //Сڶֵʱֵ
 164   2              }       
 165   1              if(ERRORX_In>500){ERRORX_In=500;}
 166   1          else if(ERRORX_In<-500){ERRORX_In=-500;}//޷
 167   1              
 168   1              PID_x=(Angle_gy+Out_PID_X)*In_XP+ERRORX_In*In_XI+(Angle_gy-Last_Angle_gy)*In_XD;//ڻPID
 169   1              
 170   1          if(PID_x>1000){PID_x=1000;}  //޷
 171   1              if(PID_x<-1000){PID_x=-1000;}
C51 COMPILER V9.01   MICROPILOT                                                            04/30/2017 10:50:26 PAGE 4   

 172   1              
 173   1              speed0=0-PID_x,speed2=0+PID_x;
 174   1      //**************Yָ**************************************************
 175   1              if(RxBuf[2]>=143||RxBuf[2]<=113);else{RxBuf[2]=128;}
 176   1              FR2=((float)RxBuf[2]-128)/7; //charתΪfloatԱ
 177   1              Ay=Angley+FR2-a_y;      //ǶȿǶ
 178   1              
 179   1              if(YM>20)
 180   1              {
 181   2        ERRORY_Out+=Ay;//⻷(Сĳֵʱ)
 182   2              }
 183   1              else
 184   1              {
 185   2                      ERRORY_Out=0; //Сڶֵʱֵ
 186   2              }       
 187   1              if(ERRORY_Out>500){ERRORY_Out=500;}
 188   1              else if(ERRORY_Out<-500){ERRORY_Out=-500;}//޷
 189   1              
 190   1              Out_PID_Y=Ay*Out_YP+ERRORY_Out*Out_YI;//⻷PI
 191   1              
 192   1              if(YM>20)
 193   1              {
 194   2        ERRORY_In+=(Angle_gx-Out_PID_Y);  //ڻ(Сĳֵʱ)
 195   2              }               
 196   1              else
 197   1              {
 198   2                      ERRORY_In=0; //Сڶֵʱֵ
 199   2              }       
 200   1              if(ERRORY_In>500){ERRORY_In=500;}
 201   1        else if(ERRORY_In<-500){ERRORY_In=-500;}//޷
 202   1              
 203   1              PID_y=(Angle_gx+Out_PID_Y)*In_YP+ERRORY_In*In_YI+(Angle_gx-Last_Angle_gx)*In_YD;//ڻPID
 204   1              
 205   1        if(PID_y>1000){PID_y=1000;}  //޷
 206   1              if(PID_y<-1000){PID_y=-1000;}
 207   1              
 208   1              speed3=0+PID_y,speed1=0-PID_y;//صٶȲ
 209   1      //**************Zָ(ZûҪϴPID)*****************************        
 210   1              FR3=((float)RxBuf[3]-128)*1.5;
 211   1              Angle_gz-=FR3; 
 212   1              PID_z=(Angle_gz)*ZP+(Angle_gz-Anglezlate)*ZD;
 213   1              Anglezlate=Angle_gz;
 214   1              speed0=speed0+PID_z,speed2=speed2+PID_z;
 215   1              speed1=speed1-PID_z,speed3=speed3-PID_z;
 216   1      //*****************ڼߴ***************************************************
 217   1              ich1=Ax;
 218   1              ich2=Ay;
 219   1              ich3=AngleAx;                 //˴ɷ6λҪʲôڴ˴޸ļ
 220   1              ich4=AngleAy;
 221   1              ich5=0;
 222   1              ich6=0;
 223   1      //**************ٶȲPWMģ*************************************************        
 224   1              PWM0=(1000-YM*4+speed0);
 225   1              if(PWM0>1000){PWM0=1000;}    //ٶȲƣֹPWMΧ0-1000
 226   1              else if(PWM0<0){PWM0=0;}
 227   1      
 228   1              PWM1=(1000-YM*4+speed1);
 229   1              if(PWM1>1000){PWM1=1000;}
 230   1              else if(PWM1<0){PWM1=0;}
 231   1      
 232   1              PWM2=(1000-YM*4+speed2);
 233   1              if(PWM2>1000){PWM2=1000;}
C51 COMPILER V9.01   MICROPILOT                                                            04/30/2017 10:50:26 PAGE 5   

 234   1              else if(PWM2<0){PWM2=0;}
 235   1              
 236   1              PWM3=(1000-YM*4+speed3);
 237   1              if(PWM3>1000){PWM3=1000;}
 238   1              else if(PWM3<0){PWM3=0;}
 239   1        if(YM>=10)
 240   1              {PWM(PWM1,PWM2,PWM0,PWM3);}//1203
 241   1              else 
 242   1              {PWM(1000,1000,1000,1000);}
 243   1      
 244   1      } 
 245          void main()
 246          {
 247   1      PWMGO();//ʼPWM
 248   1      IAPRead();//ȡǾ
 249   1      InitMPU6050();//ʼMPU-6050
 250   1      Usart_Init();//ʼ
 251   1      Time0_Init();//ʼʱ
 252   1      RxBuf[1]=128;
 253   1      RxBuf[2]=128;
 254   1      RxBuf[3]=128;
 255   1      RxBuf[4]=0;
 256   1      while(1)
 257   1      {          
 258   2                                      Delay(500);
 259   2                                      nRF24L01_RxPacket(RxBuf);
 260   2                                      if(RxBuf[5]==1&&i>128)  
 261   2              {
 262   3                                      IAP_Gyro();
 263   3                                      RxBuf[5]=0;
 264   3                                      EA=0;
 265   3                                      PWMCKS=0x10;         
 266   3                                      T2L = 0xEB;     
 267   3                          T2H = 0xFF;
 268   3                                      PWM(960,960,960,960);
 269   3                  Delay(60000); //У׼ϵһ
 270   3              PWM(1000,1000,1000,1000);       
 271   3              PWMCKS=0x00;
 272   3              EA=1;
 273   3              i=0;                                    
 274   3                                      }
 275   2                                      if(RxBuf[6]==1&&i>128)  
 276   2              {
 277   3                                      IAP_Angle();
 278   3                                      RxBuf[6]=0;
 279   3                                      EA=0;
 280   3                                      PWMCKS=0x10;         
 281   3                                      T2L = 0xEB;     
 282   3                    T2H = 0xFF;
 283   3                                      PWM(960,960,960,960);
 284   3                    Delay(60000);  //У׼ϵһ
 285   3              PWM(1000,1000,1000,1000);       
 286   3              PWMCKS=0x00;
 287   3                                      EA=1;   
 288   3                                      i=0;
 289   3                                      }
 290   2                    //Send(ich1,ich2,ich3,ich4,ich5,ich6);  //ڷ  λȡעͱ䣡עͱ
             -Ϊ˼Сңʱ
 291   2      }
 292   1      }


C51 COMPILER V9.01   MICROPILOT                                                            04/30/2017 10:50:26 PAGE 6   

MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4234    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    276    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
